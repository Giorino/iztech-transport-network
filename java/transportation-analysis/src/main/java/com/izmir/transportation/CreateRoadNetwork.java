package com.izmir.transportation;

import java.awt.Color;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.Reader;
import java.io.Serializable;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.apache.commons.csv.CSVFormat;
import org.apache.commons.csv.CSVParser;
import org.apache.commons.csv.CSVPrinter;
import org.apache.commons.csv.CSVRecord;
import org.geotools.data.DefaultTransaction;
import org.geotools.data.Transaction;
import org.geotools.data.shapefile.ShapefileDataStore;
import org.geotools.data.shapefile.ShapefileDataStoreFactory;
import org.geotools.data.simple.SimpleFeatureStore;
import org.geotools.feature.DefaultFeatureCollection;
import org.geotools.feature.simple.SimpleFeatureBuilder;
import org.geotools.feature.simple.SimpleFeatureTypeBuilder;
import org.geotools.geometry.jts.JTSFactoryFinder;
import org.geotools.map.FeatureLayer;
import org.geotools.map.MapContent;
import org.geotools.referencing.crs.DefaultGeographicCRS;
import org.geotools.styling.SLD;
import org.geotools.styling.Style;
import org.geotools.swing.JMapFrame;
import org.jgrapht.Graph;
import org.jgrapht.GraphPath;
import org.jgrapht.alg.shortestpath.DijkstraShortestPath;
import org.jgrapht.graph.DefaultWeightedEdge;
import org.jgrapht.graph.SimpleWeightedGraph;
import org.locationtech.jts.geom.Coordinate;
import org.locationtech.jts.geom.Envelope;
import org.locationtech.jts.geom.GeometryFactory;
import org.locationtech.jts.geom.LineString;
import org.locationtech.jts.geom.Point;
import org.locationtech.jts.index.strtree.ItemBoundable;
import org.locationtech.jts.index.strtree.STRtree;
import org.opengis.feature.simple.SimpleFeatureType;

/**
 * A class for creating and analyzing a road network based on generated points and OpenStreetMap data.
 * This class handles the creation of a graph structure connecting the random points generated by IzmirBayGraph,
 * using actual road data from OpenStreetMap to create realistic connections.
 * 
 * @author yagizugurveren
 */
public class CreateRoadNetwork {
    private static final GeometryFactory geometryFactory = JTSFactoryFinder.getGeometryFactory();

    /**
     * Main method to create and analyze the road network.
     * Loads points from CSV, creates a network, and visualizes the results.
     *
     * @param args Command line arguments (not used in current implementation)
     */
    public static void main(String[] args) {
        try {
            // Read the random points
            System.out.println("Loading points...");
            List<Point> points = loadPoints("random_izmir_points.csv");

            // Get bounding box
            Envelope bbox = getBoundingBox(points);
            double padding = 0.02;
            bbox.expandBy(padding);

            // Download road network (using OpenStreetMap data)
            System.out.println("Loading road network...");
            Graph<Point, DefaultWeightedEdge> roadNetwork = loadRoadNetwork(bbox);

            // Snap points to nearest network nodes
            System.out.println("Snapping points to nearest network nodes...");
            Map<Point, Point> pointToNode = snapPointsToNetwork(points, roadNetwork);

            // Create edges between points using shortest paths
            System.out.println("Creating edges using shortest paths...");
            List<List<Point>> paths = createPaths(points, pointToNode, roadNetwork);

            // Visualize the results
            visualizeNetwork(roadNetwork, points, paths);

            // Save the network data
            System.out.println("Saving network data...");
            saveNetworkData(roadNetwork, points, pointToNode, paths, false);

            System.out.println("Done! Network data has been saved.");

        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * Loads points from a CSV file.
     *
     * @param csvFile Path to the CSV file containing point data
     * @return List of points loaded from the file
     * @throws IOException If there is an error reading the file
     */
    private static List<Point> loadPoints(String csvFile) throws IOException {
        List<Point> points = new ArrayList<>();
        try (Reader reader = new FileReader(csvFile);
             CSVParser csvParser = new CSVParser(reader, CSVFormat.DEFAULT.withFirstRecordAsHeader())) {
            for (CSVRecord record : csvParser) {
                double longitude = Double.parseDouble(record.get("longitude"));
                double latitude = Double.parseDouble(record.get("latitude"));
                points.add(geometryFactory.createPoint(new Coordinate(longitude, latitude)));
            }
        }
        return points;
    }

    /**
     * Calculates the bounding box for a set of points with additional buffer.
     *
     * @param points List of points to calculate the bounding box for
     * @return Envelope representing the bounding box
     */
    private static Envelope getBoundingBox(List<Point> points) {
        // First get the basic bounding box from points
        Envelope bbox = new Envelope();
        for (Point point : points) {
            bbox.expandToInclude(point.getCoordinate());
        }
        
        // Add a significant buffer (about 20% of the width/height) to ensure we get connecting roads
        double widthBuffer = bbox.getWidth() * 0.2;
        double heightBuffer = bbox.getHeight() * 0.2;
        
        // Create a new envelope with the buffer
        return new Envelope(
            bbox.getMinX() - widthBuffer,
            bbox.getMaxX() + widthBuffer,
            bbox.getMinY() - heightBuffer,
            bbox.getMaxY() + heightBuffer
        );
    }

    /**
     * Loads the road network from OpenStreetMap data within the specified bounding box.
     *
     * @param bbox Bounding box defining the area to load
     * @return Graph representing the road network
     * @throws Exception If there is an error loading or processing the OSM data
     */
    private static Graph<Point, DefaultWeightedEdge> loadRoadNetwork(Envelope bbox) throws Exception {
        // Create a weighted graph
        Graph<Point, DefaultWeightedEdge> graph = new SimpleWeightedGraph<>(DefaultWeightedEdge.class);

        // Add a small additional buffer for the OSM query to ensure we get complete roads
        Envelope queryBbox = new Envelope(bbox);
        queryBbox.expandBy(0.01); // Add 0.01 degrees buffer (roughly 1km)

        // Download or load from cache OSM data
        System.out.println("Loading OpenStreetMap data...");
        Map<String, Object> osmData = OSMDataCache.getOrDownloadData(queryBbox);
        
        // Add nodes to graph
        @SuppressWarnings("unchecked")
        Map<String, Point> nodes = (Map<String, Point>) osmData.get("nodes");
        for (Point point : nodes.values()) {
            graph.addVertex(point);
        }

        // Add edges to graph
        @SuppressWarnings("unchecked")
        List<LineString> ways = (List<LineString>) osmData.get("ways");
        for (LineString way : ways) {
            Coordinate[] coords = way.getCoordinates();
            for (int i = 0; i < coords.length - 1; i++) {
                Point p1 = geometryFactory.createPoint(coords[i]);
                Point p2 = geometryFactory.createPoint(coords[i + 1]);
                
                if (!graph.containsVertex(p1)) {
                    graph.addVertex(p1);
                }
                if (!graph.containsVertex(p2)) {
                    graph.addVertex(p2);
                }
                
                DefaultWeightedEdge edge = graph.addEdge(p1, p2);
                if (edge != null) {
                    double distance = OSMUtils.calculateLength(
                        geometryFactory.createLineString(new Coordinate[]{coords[i], coords[i + 1]})
                    );
                    graph.setEdgeWeight(edge, distance);
                }
            }
        }

        System.out.println("Road network loaded: " + graph.vertexSet().size() + " nodes, " + 
                          graph.edgeSet().size() + " edges");
        return graph;
    }

    /**
     * Maps input points to their nearest nodes in the road network.
     *
     * @param points List of input points to snap to the network
     * @param network The road network graph
     * @return Map linking input points to their nearest network nodes
     */
    private static Map<Point, Point> snapPointsToNetwork(List<Point> points, Graph<Point, DefaultWeightedEdge> network) {
        Map<Point, Point> pointToNode = new HashMap<>();
        STRtree spatialIndex = new STRtree();

        // Build spatial index of network nodes
        for (Point node : network.vertexSet()) {
            spatialIndex.insert(node.getEnvelopeInternal(), node);
        }

        // Find nearest network node for each point
        for (Point point : points) {
            Object nearestObj = spatialIndex.nearestNeighbour(
                    point.getEnvelopeInternal(),
                    point,
                    (item1, item2) -> {
                        Point p1 = (Point) ((ItemBoundable) item1).getItem();
                        Point p2 = (Point) ((ItemBoundable) item2).getItem();
                        return p1.distance(p2);
                    });
            Point nearestNode = (Point) nearestObj;
            pointToNode.put(point, nearestNode);
        }

        return pointToNode;
    }

    /**
     * Creates paths between points using shortest path algorithms on the road network.
     *
     * @param points Original input points
     * @param pointToNode Mapping of input points to network nodes
     * @param network The road network graph
     * @return List of paths connecting the points
     */
    private static List<List<Point>> createPaths(List<Point> points, Map<Point, Point> pointToNode,
                                               Graph<Point, DefaultWeightedEdge> network) {
        List<List<Point>> paths = new ArrayList<>();
        DijkstraShortestPath<Point, DefaultWeightedEdge> dijkstra = new DijkstraShortestPath<>(network);

        // Create transportation graph
        TransportationGraph transportationGraph = new TransportationGraph(points);

        // Update node mappings
        for (Map.Entry<Point, Point> entry : pointToNode.entrySet()) {
            transportationGraph.updateNodeMapping(entry.getKey(), entry.getValue());
        }

        // Connect each point to its k nearest neighbors
        int k = 5;  // Number of nearest neighbors to connect to
        int maxAttempts = 5;  // Maximum number of attempts to find valid neighbors
        
        for (int i = 0; i < points.size(); i++) {
            Point p1 = points.get(i);
            Point node1 = pointToNode.get(p1);

            // Calculate distances to all other points
            List<PointDistance> distances = new ArrayList<>();
            for (int j = 0; j < points.size(); j++) {
                if (i != j) {
                    Point p2 = points.get(j);
                    double distance = p1.distance(p2);
                    distances.add(new PointDistance(j, distance));
                }
            }

            // Sort by distance and try to connect to k nearest neighbors
            distances.sort(Comparator.comparingDouble(PointDistance::getDistance));
            int connectedPaths = 0;
            int attemptIndex = 0;
            
            while (connectedPaths < k && attemptIndex < Math.min(maxAttempts * k, distances.size())) {
                Point p2 = points.get(distances.get(attemptIndex).getIndex());
                Point node2 = pointToNode.get(p2);

                GraphPath<Point, DefaultWeightedEdge> path = dijkstra.getPath(node1, node2);
                if (path != null) {
                    List<Point> pathPoints = new ArrayList<>(path.getVertexList());
                    paths.add(pathPoints);
                    
                    // Add connection to transportation graph with actual path distance in meters
                    double pathDistance = path.getWeight(); // Weight is already in meters from OSMUtils.calculateLength
                    transportationGraph.addConnection(p1, p2, pathDistance);
                    
                    connectedPaths++;
                }
                attemptIndex++;
            }
        }

        // Visualize the transportation graph
        transportationGraph.visualizeGraph();

        return paths;
    }

    /**
     * Visualizes the network, points, and paths on a map.
     *
     * @param network The road network graph
     * @param points Original input points
     * @param paths List of paths connecting the points
     * @throws Exception If there is an error creating or showing the map
     */
    private static void visualizeNetwork(Graph<Point, DefaultWeightedEdge> network, List<Point> points,
                                       List<List<Point>> paths) throws Exception {
        // Create feature types
        SimpleFeatureTypeBuilder pointBuilder = new SimpleFeatureTypeBuilder();
        pointBuilder.setName("Points");
        pointBuilder.setCRS(DefaultGeographicCRS.WGS84);
        pointBuilder.add("geometry", Point.class);
        SimpleFeatureType pointType = pointBuilder.buildFeatureType();

        SimpleFeatureTypeBuilder networkBuilder = new SimpleFeatureTypeBuilder();
        networkBuilder.setName("Network");
        networkBuilder.setCRS(DefaultGeographicCRS.WGS84);
        networkBuilder.add("geometry", LineString.class);
        SimpleFeatureType networkType = networkBuilder.buildFeatureType();

        // Create features collections
        DefaultFeatureCollection pointCollection = new DefaultFeatureCollection();
        DefaultFeatureCollection networkCollection = new DefaultFeatureCollection();
        DefaultFeatureCollection pathCollection = new DefaultFeatureCollection();

        // Add points
        SimpleFeatureBuilder pointFeatureBuilder = new SimpleFeatureBuilder(pointType);
        for (Point point : points) {
            pointFeatureBuilder.add(point);
            pointCollection.add(pointFeatureBuilder.buildFeature(null));
        }

        // Add network edges
        SimpleFeatureBuilder networkFeatureBuilder = new SimpleFeatureBuilder(networkType);
        for (DefaultWeightedEdge edge : network.edgeSet()) {
            Point source = network.getEdgeSource(edge);
            Point target = network.getEdgeTarget(edge);
            LineString line = geometryFactory.createLineString(new Coordinate[]{
                source.getCoordinate(),
                target.getCoordinate()
            });
            networkFeatureBuilder.add(line);
            networkCollection.add(networkFeatureBuilder.buildFeature(null));
        }

        // Add paths (only if they have at least 2 points)
        for (List<Point> path : paths) {
            if (path.size() >= 2) {  // Only create LineString if we have at least 2 points
                Coordinate[] coords = path.stream()
                        .map(Point::getCoordinate)
                        .toArray(Coordinate[]::new);
                LineString line = geometryFactory.createLineString(coords);
                networkFeatureBuilder.add(line);
                pathCollection.add(networkFeatureBuilder.buildFeature(null));
            }
        }

        // Create styles
        Style networkStyle = SLD.createLineStyle(Color.LIGHT_GRAY, 0.5f);  // Make base network lighter
        Style pointStyle = SLD.createPointStyle("circle", Color.BLACK, Color.RED, 1, 7);
        Style pathStyle = SLD.createLineStyle(Color.BLUE, 2);

        // Create map
        MapContent map = new MapContent();
        map.setTitle("Izmir Transportation Network");
        map.addLayer(new FeatureLayer(networkCollection, networkStyle));
        map.addLayer(new FeatureLayer(pathCollection, pathStyle));
        map.addLayer(new FeatureLayer(pointCollection, pointStyle));

        // Show map
        JMapFrame.showMap(map);
    }

    /**
     * Saves the network data to files for future use.
     *
     * @param network The road network graph
     * @param points Original input points
     * @param pointToNode Mapping of input points to network nodes
     * @param paths List of paths connecting the points
     * @throws IOException If there is an error saving the data
     */
    private static void saveNetworkData(Graph<Point, DefaultWeightedEdge> network, List<Point> points,
                                      Map<Point, Point> pointToNode, List<List<Point>> paths, boolean buildShapeFile) throws IOException {
        System.out.println("Saving node locations to CSV...");
        // Save node locations
        try (CSVPrinter printer = new CSVPrinter(
                new FileWriter("izmir_network_nodes.csv", StandardCharsets.UTF_8),
                CSVFormat.DEFAULT.withHeader("node_id", "network_node_id", "longitude", "latitude"))) {
            for (int i = 0; i < points.size(); i++) {
                Point point = points.get(i);
                Point node = pointToNode.get(point);
                printer.printRecord(i, node.hashCode(), point.getX(), point.getY());
            }
        }

        if(buildShapeFile){
            System.out.println("Setting up shapefile structure...");
            // Save network as shapefile
            SimpleFeatureTypeBuilder builder = new SimpleFeatureTypeBuilder();
            builder.setName("Roads");
            builder.setCRS(DefaultGeographicCRS.WGS84);
            builder.add("geometry", LineString.class);
            builder.add("edge_id", Integer.class);
            SimpleFeatureType roadType = builder.buildFeatureType();

            File file = new File("izmir_road_network.shp");
            Map<String, Serializable> params = new HashMap<>();
            params.put("url", file.toURI().toURL());
            params.put("create spatial index", Boolean.TRUE);

            ShapefileDataStoreFactory dataStoreFactory = new ShapefileDataStoreFactory();
            ShapefileDataStore dataStore = (ShapefileDataStore) dataStoreFactory.createDataStore(params);
            dataStore.createSchema(roadType);

            Transaction transaction = new DefaultTransaction("create");
            String typeName = dataStore.getTypeNames()[0];
            SimpleFeatureStore featureStore = (SimpleFeatureStore) dataStore.getFeatureSource(typeName);
            featureStore.setTransaction(transaction);

            try {
                System.out.println("Starting to save edges to shapefile...");
                int totalEdges = network.edgeSet().size();
                int batchSize = 10000;
                int currentBatch = 0;
                DefaultFeatureCollection roads = new DefaultFeatureCollection();
                SimpleFeatureBuilder featureBuilder = new SimpleFeatureBuilder(roadType);

                int edgeCounter = 0;
                for (DefaultWeightedEdge edge : network.edgeSet()) {
                    Point source = network.getEdgeSource(edge);
                    Point target = network.getEdgeTarget(edge);
                    LineString line = geometryFactory.createLineString(new Coordinate[]{
                            source.getCoordinate(),
                            target.getCoordinate()
                    });
                    featureBuilder.add(line);
                    featureBuilder.add(edgeCounter);
                    roads.add(featureBuilder.buildFeature(String.valueOf(edgeCounter)));

                    edgeCounter++;

                    // Process in batches to manage memory
                    if (roads.size() >= batchSize || edgeCounter == totalEdges) {
                        currentBatch++;
                        System.out.printf("Saving batch %d (edges %d-%d of %d)...%n",
                                currentBatch, (currentBatch-1)*batchSize,
                                Math.min(currentBatch*batchSize, totalEdges), totalEdges);

                        featureStore.addFeatures(roads);
                        roads.clear();

                        // Commit each batch
                        transaction.commit();
                        System.gc(); // Suggest garbage collection after each batch
                    }
                }

                System.out.println("Successfully saved all edges to shapefile.");
            } catch (Exception e) {
                System.err.println("Error saving shapefile: " + e.getMessage());
                transaction.rollback();
                throw new IOException("Error saving shapefile", e);
            } finally {
                transaction.close();
                dataStore.dispose();
            }
        }

        System.out.println("Network data save completed successfully.");
    }

    
    
} 