package com.izmir.transportation;

import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Font;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.RenderingHints;
import java.awt.image.BufferedImage;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Random;
import java.util.concurrent.ConcurrentHashMap;

import javax.swing.JFrame;
import javax.swing.JPanel;
import javax.swing.SwingUtilities;

import org.geotools.data.DataUtilities;
import org.geotools.feature.DefaultFeatureCollection;
import org.geotools.feature.simple.SimpleFeatureBuilder;
import org.geotools.feature.simple.SimpleFeatureTypeBuilder;
import org.geotools.geometry.jts.JTSFactoryFinder;
import org.geotools.map.FeatureLayer;
import org.geotools.map.Layer;
import org.geotools.map.MapContent;
import org.geotools.referencing.crs.DefaultGeographicCRS;
import org.geotools.styling.SLD;
import org.geotools.styling.Style;
import org.geotools.swing.JMapFrame;
import org.jgrapht.Graph;
import org.jgrapht.graph.DefaultWeightedEdge;
import org.jgrapht.graph.SimpleWeightedGraph;
import org.locationtech.jts.geom.Coordinate;
import org.locationtech.jts.geom.GeometryFactory;
import org.locationtech.jts.geom.LineString;
import org.locationtech.jts.geom.Point;
import org.opengis.feature.simple.SimpleFeature;
import org.opengis.feature.simple.SimpleFeatureType;

import com.izmir.transportation.helper.Edge;
import com.izmir.transportation.helper.Node;
import com.izmir.transportation.helper.clustering.GraphClusteringAlgorithm;

/**
 * A class that models the Izmir transportation network as a weighted graph structure.
 * This class integrates with IzmirBayGraph's point generation and CreateRoadNetwork's path calculations
 * to create a comprehensive graph representation of the transportation network.
 *
 * The graph uses JGraphT's SimpleWeightedGraph with Point vertices and DefaultWeightedEdge edges,
 * where edge weights represent actual path distances calculated from the road network.
 *
 * @author yagizugurveren
 */
public class TransportationGraph {
    private final Graph<Node, DefaultWeightedEdge> graph;
    private final Map<Point, Node> pointToNode;
    private final GeometryFactory geometryFactory;
    private final Map<DefaultWeightedEdge, Edge> edgeMap;
    private double maxDistance = 0.0;
    private static final double MIN_EDGE_WIDTH = 1.0;
    private static final double MAX_EDGE_WIDTH = 5.0;
    private AffinityMatrix affinityMatrix;
    private final List<Point> originalPoints; // Track original points separately
    private String graphConstructionMethod; // Construction method to be set from App.java

    /**
     * Constructs a new TransportationGraph with the given points.
     *
     * @param originalPoints List of points generated by IzmirBayGraph
     */
    public TransportationGraph(List<Point> originalPoints) {
        this.graph = new SimpleWeightedGraph<>(DefaultWeightedEdge.class);
        this.pointToNode = new ConcurrentHashMap<>();
        this.edgeMap = new ConcurrentHashMap<>();
        this.geometryFactory = JTSFactoryFinder.getGeometryFactory();
        this.originalPoints = new ArrayList<>(originalPoints); // Store original points

        for (Point point : originalPoints) {
            Node node = new Node(String.valueOf(point.hashCode()), point);
            graph.addVertex(node);
            pointToNode.put(point, node);
        }
    }

    /**
     * Updates the mapping between an original point and its corresponding network node.
     *
     * @param originalPoint The original point from IzmirBayGraph
     * @param networkPoint The corresponding point in the road network
     */
    public void updateNodeMapping(Point originalPoint, Point networkPoint) {
        Node networkNode = new Node(String.valueOf(networkPoint.hashCode()), networkPoint);

        if (!graph.containsVertex(networkNode)) {
            graph.addVertex(networkNode);
        }
        pointToNode.put(originalPoint, networkNode);
    }

    /**
     * Adds a weighted connection between two points in the graph.
     *
     * @param source The source point
     * @param target The target point
     * @param distance The distance of the connection in meters
     * @return The created edge, or null if the connection couldn't be made
     */
    public synchronized DefaultWeightedEdge addConnection(Point source, Point target, double distance) {
        if (source == null || target == null || distance <= 0) {
            return null;
        }

        Node sourceNode = pointToNode.get(source);
        Node targetNode = pointToNode.get(target);

        if (sourceNode == null || targetNode == null) {
            return null;
        }

        synchronized (graph) {
            if (!graph.containsVertex(sourceNode)) {
                graph.addVertex(sourceNode);
            }
            if (!graph.containsVertex(targetNode)) {
                graph.addVertex(targetNode);
            }

            DefaultWeightedEdge graphEdge = graph.addEdge(sourceNode, targetNode);
            if (graphEdge != null) {
                synchronized (this) {
                    maxDistance = Math.max(maxDistance, distance);

                    LineString geometry = geometryFactory.createLineString(new Coordinate[]{
                        source.getCoordinate(),
                        target.getCoordinate()
                    });

                    Edge edge = new Edge(
                        String.valueOf(graphEdge.hashCode()),
                        sourceNode,
                        targetNode,
                        geometry,
                        distance
                    );

                    edgeMap.put(graphEdge, edge);
                    graph.setEdgeWeight(graphEdge, distance);
                }
            }
            return graphEdge;
        }
    }

    /**
     * Updates the weights of all edges in the graph based on the current maximum distance.
     */
    private synchronized void updateEdgeWeights() {
        double localMaxDistance = maxDistance;
        for (Map.Entry<DefaultWeightedEdge, Edge> entry : edgeMap.entrySet()) {
            Edge edge = entry.getValue();
            edge.normalizeWeight(localMaxDistance);
            graph.setEdgeWeight(entry.getKey(), edge.getNormalizedWeight());
        }
    }

    /**
     * Creates and displays a visualization of the transportation network graph.
     * The visualization shows nodes as red circles and edges as blue lines with
     * thickness proportional to their weights.
     */
    public void visualizeGraph() {
        try {
            // Update all edge weights before visualization
            updateEdgeWeights();

            // Create the visualization on the Event Dispatch Thread
            SwingUtilities.invokeLater(() -> {
                try {
                    SimpleFeatureTypeBuilder pointBuilder = new SimpleFeatureTypeBuilder();
                    pointBuilder.setName("Nodes");
                    pointBuilder.setCRS(DefaultGeographicCRS.WGS84);
                    pointBuilder.add("geometry", Point.class);
                    pointBuilder.add("id", String.class);
                    SimpleFeatureType pointType = pointBuilder.buildFeatureType();

                    SimpleFeatureTypeBuilder lineBuilder = new SimpleFeatureTypeBuilder();
                    lineBuilder.setName("Edges");
                    lineBuilder.setCRS(DefaultGeographicCRS.WGS84);
                    lineBuilder.add("geometry", LineString.class);
                    lineBuilder.add("weight", Double.class);
                    lineBuilder.add("label", String.class);
                    SimpleFeatureType lineType = lineBuilder.buildFeatureType();

                    DefaultFeatureCollection nodes = new DefaultFeatureCollection();
                    DefaultFeatureCollection edges = new DefaultFeatureCollection();
                    DefaultFeatureCollection pathCollection = new DefaultFeatureCollection();

                    SimpleFeatureBuilder pointFeatureBuilder = new SimpleFeatureBuilder(pointType);
                    for (Node node : graph.vertexSet()) {
                        pointFeatureBuilder.add(node.getLocation());
                        pointFeatureBuilder.add(node.getId());
                        SimpleFeature feature = pointFeatureBuilder.buildFeature(null);
                        nodes.add(feature);
                    }

                    SimpleFeatureBuilder lineBuilder2 = new SimpleFeatureBuilder(lineType);
                    for (Map.Entry<DefaultWeightedEdge, Edge> entry : edgeMap.entrySet()) {
                        Edge edge = entry.getValue();
                        double weight = edge.getNormalizedWeight();

                        lineBuilder2.add(edge.getGeometry());
                        lineBuilder2.add(weight);
                        lineBuilder2.add(String.format("%.3f", weight));
                        SimpleFeature feature = lineBuilder2.buildFeature(null);
                        edges.add(feature);
                    }

                    Style nodeStyle = SLD.createPointStyle("circle", Color.BLACK, Color.RED, 1.0f, 7);

                    Layer nodesLayer = new FeatureLayer(nodes, nodeStyle);

                    MapContent map = new MapContent();
                    map.setTitle("Izmir Transportation Network Graph");

                    for (Map.Entry<DefaultWeightedEdge, Edge> entry : edgeMap.entrySet()) {
                        Edge edge = entry.getValue();
                        double weight = edge.getNormalizedWeight();

                        float lineWidth = (float) (MIN_EDGE_WIDTH +
                            weight * (MAX_EDGE_WIDTH - MIN_EDGE_WIDTH));

                        SimpleFeatureType edgeType = DataUtilities.createType("Edge",
                            "geometry:LineString,weight:Double,label:String");
                        SimpleFeatureBuilder edgeBuilder = new SimpleFeatureBuilder(edgeType);

                        edgeBuilder.add(edge.getGeometry());
                        edgeBuilder.add(weight);
                        edgeBuilder.add(String.format("%.3f", weight));

                        DefaultFeatureCollection edgeCollection = new DefaultFeatureCollection();
                        edgeCollection.add(edgeBuilder.buildFeature(null));

                        org.geotools.styling.StyleBuilder styleBuilder = new org.geotools.styling.StyleBuilder();

                        org.geotools.styling.LineSymbolizer lineSymbolizer = styleBuilder.createLineSymbolizer(Color.LIGHT_GRAY, lineWidth);

                        org.geotools.styling.TextSymbolizer textSymbolizer = styleBuilder.createTextSymbolizer();
                        textSymbolizer.setLabel(styleBuilder.attributeExpression("label"));
                        textSymbolizer.setFill(styleBuilder.createFill(Color.BLACK));
                        textSymbolizer.setFont(styleBuilder.createFont("Arial", 12));

                        org.geotools.styling.Rule rule = styleBuilder.createRule(new org.geotools.styling.Symbolizer[]{
                            lineSymbolizer,
                            textSymbolizer
                        });
                        org.geotools.styling.FeatureTypeStyle fts = styleBuilder.createFeatureTypeStyle("Edge", rule);
                        Style edgeStyle = styleBuilder.createStyle();
                        edgeStyle.featureTypeStyles().add(fts);

                        Layer edgeLayer = new FeatureLayer(edgeCollection, edgeStyle);
                        map.addLayer(edgeLayer);
                    }

                    map.addLayer(nodesLayer);

                    JMapFrame mapFrame = new JMapFrame(map);
                    mapFrame.enableToolBar(true);
                    mapFrame.enableStatusBar(true);
                    mapFrame.setSize(800, 600);
                    mapFrame.setLocationRelativeTo(null);
                    mapFrame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
                    mapFrame.setVisible(true);
                } catch (Exception e) {
                    System.err.println("Error in graph visualization: " + e.getMessage());
                    e.printStackTrace();
                }
            });

        } catch (Exception e) {
            System.err.println("Error preparing graph visualization: " + e.getMessage());
            e.printStackTrace();
        }
    }

    /**
     * Creates and saves the affinity matrix for the transportation network.
     * The matrix will be saved as a CSV file and then displayed in a grid format.
     */
    public void createAffinityMatrix() {
        System.out.println("Creating affinity matrix...");
        affinityMatrix = new AffinityMatrix(graph, edgeMap);

        try {
            // Save matrix data as CSV
            String csvFile = "affinity_matrix.csv";
            affinityMatrix.saveToCSV(csvFile);
            System.out.println("Affinity matrix saved to CSV file");

            // Display the CSV file in a grid and wait for it to appear
            //System.out.println("Opening affinity matrix visualization...");
            //AffinityMatrix.displayCSV(csvFile);

            System.out.println("Affinity matrix has been created and saved to: " + csvFile);
        } catch (IOException e) {
            System.err.println("Error creating affinity matrix: " + e.getMessage());
            e.printStackTrace();
        }
    }

    /**
     * Gets the affinity matrix if it has been created.
     *
     * @return The affinity matrix, or null if it hasn't been created yet
     */
    public AffinityMatrix getAffinityMatrix() {
        return affinityMatrix;
    }

    /**
     * Gets the underlying JGraphT graph structure.
     *
     * @return The graph object
     */
    public Graph<Node, DefaultWeightedEdge> getGraph() {
        return graph;
    }

    /**
     * Gets the mapping between points and their corresponding nodes.
     *
     * @return The point to node mapping
     */
    public Map<Point, Node> getPointToNode() {
        return pointToNode;
    }

    /**
     * Gets the mapping between graph edges and our custom Edge objects.
     *
     * @return The edge mapping
     */
    public Map<DefaultWeightedEdge, Edge> getEdgeMap() {
        return edgeMap;
    }

    /**
     * Gets a subgraph containing only the nodes corresponding to the original points.
     * This is used for community detection to ensure we only analyze the original points.
     *
     * @return A subgraph containing only the original point nodes
     */
    public Graph<Node, DefaultWeightedEdge> getOriginalPointsGraph() {
        Graph<Node, DefaultWeightedEdge> subgraph = new SimpleWeightedGraph<>(DefaultWeightedEdge.class);

        // Add only nodes corresponding to original points
        for (Point originalPoint : originalPoints) {
            Node node = pointToNode.get(originalPoint);
            if (node != null) {
                subgraph.addVertex(node);
            }
        }

        // Add edges between these nodes
        for (Point source : originalPoints) {
            Node sourceNode = pointToNode.get(source);
            if (sourceNode == null || !subgraph.containsVertex(sourceNode)) continue;

            for (Point target : originalPoints) {
                if (source == target) continue;

                Node targetNode = pointToNode.get(target);
                if (targetNode == null || !subgraph.containsVertex(targetNode)) continue;

                // Check if there's an edge in the original graph
                DefaultWeightedEdge edge = graph.getEdge(sourceNode, targetNode);
                if (edge != null) {
                    DefaultWeightedEdge newEdge = subgraph.addEdge(sourceNode, targetNode);
                    if (newEdge != null) {
                        subgraph.setEdgeWeight(newEdge, graph.getEdgeWeight(edge));
                    }
                }
            }
        }

        return subgraph;
    }

    public void analyzeCommunities(GraphClusteringAlgorithm algorithm) {
        List<List<Node>> communities = algorithm.findCommunities(this);
        visualizeCommunities(communities);
    }

    /**
     * Visualizes detected communities by coloring nodes and edges based on community membership.
     * Also saves the visualization as a PNG file.
     *
     * @param communities A list of communities, where each community is a list of nodes
     */
    public void visualizeCommunities(List<List<Node>> communities) {
        visualizeCommunities(communities, "community");
    }
    
    /**
     * Visualizes detected communities by coloring nodes and edges based on community membership.
     * Also saves the visualization as a PNG file with the algorithm name in the filename.
     *
     * @param communities A list of communities, where each community is a list of nodes
     * @param algorithmName The name of the algorithm used (e.g., "leiden", "spectral")
     */
    public void visualizeCommunities(List<List<Node>> communities, String algorithmName) {
        visualizeCommunities(communities, algorithmName, true);
    }
    
    /**
     * Visualizes detected communities by coloring nodes and edges based on community membership.
     * Also saves the visualization as a PNG file with the algorithm name in the filename.
     *
     * @param communities A list of communities, where each community is a list of nodes
     * @param algorithmName The name of the algorithm used (e.g., "leiden", "spectral")
     * @param showCommunityZero Whether to show community 0 (outliers) in the visualization
     */
    public void visualizeCommunities(List<List<Node>> communities, String algorithmName, boolean showCommunityZero) {
        if (communities == null || communities.isEmpty()) {
            System.out.println("No communities to visualize.");
            return;
        }

        // Create a map of node to community ID for quick lookup
        Map<Node, Integer> nodeCommunities = new HashMap<>();
        for (int i = 0; i < communities.size(); i++) {
            // Skip community 0 if showCommunityZero is false
            if (!showCommunityZero && i == 0) {
                continue;
            }
            
            List<Node> community = communities.get(i);
            for (Node node : community) {
                nodeCommunities.put(node, i);
            }
        }

        // Post-process to ensure all nodes have a community assignment
        // This prevents black nodes in visualization
        assignMissingCommunities(nodeCommunities);

        // Generate distinct colors for each community (max 20 unique colors)
        List<Color> communityColors = generateCommunityColors(communities.size());

        // Create a visualization frame
        JFrame frame = new JFrame("Izmir Transportation Network - " + algorithmName.substring(0, 1).toUpperCase() + algorithmName.substring(1) + " Communities");
        frame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
        frame.setSize(1200, 800);

        // Create a panel for drawing
        JPanel panel = new JPanel() {
            @Override
            protected void paintComponent(Graphics g) {
                super.paintComponent(g);
                Graphics2D g2d = (Graphics2D) g;
                g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);

                // Fill with white background
                g2d.setColor(Color.WHITE);
                g2d.fillRect(0, 0, getWidth(), getHeight());

                // Calculate scaling factors
                double minX = Double.MAX_VALUE;
                double maxX = Double.MIN_VALUE;
                double minY = Double.MAX_VALUE;
                double maxY = Double.MIN_VALUE;

                for (Node node : graph.vertexSet()) {
                    Point location = node.getLocation();
                    minX = Math.min(minX, location.getX());
                    maxX = Math.max(maxX, location.getX());
                    minY = Math.min(minY, location.getY());
                    maxY = Math.max(maxY, location.getY());
                }

                double width = getWidth() - 40;
                double height = getHeight() - 40;
                double xScale = width / (maxX - minX);
                double yScale = height / (maxY - minY);
                double scale = Math.min(xScale, yScale);

                // Draw edges first
                g2d.setStroke(new BasicStroke(1.0f));
                for (DefaultWeightedEdge edge : graph.edgeSet()) {
                    Node source = graph.getEdgeSource(edge);
                    Node target = graph.getEdgeTarget(edge);

                    // Get community IDs for source and target
                    Integer sourceCommunity = nodeCommunities.get(source);
                    Integer targetCommunity = nodeCommunities.get(target);
                    
                    // Skip edges connected to community 0 if we're hiding it
                    if (!showCommunityZero && (sourceCommunity != null && sourceCommunity == 0 || 
                        targetCommunity != null && targetCommunity == 0)) {
                        continue;
                    }

                    // Draw edge in gray if nodes belong to different communities
                    if (sourceCommunity != null && targetCommunity != null && sourceCommunity.equals(targetCommunity)) {
                        g2d.setColor(communityColors.get(sourceCommunity % communityColors.size()));
                    } else {
                        g2d.setColor(Color.LIGHT_GRAY);
                    }

                    int x1 = 20 + (int)((source.getLocation().getX() - minX) * scale);
                    int y1 = getHeight() - 20 - (int)((source.getLocation().getY() - minY) * scale);
                    int x2 = 20 + (int)((target.getLocation().getX() - minX) * scale);
                    int y2 = getHeight() - 20 - (int)((target.getLocation().getY() - minY) * scale);

                    g2d.drawLine(x1, y1, x2, y2);
                }

                // Draw nodes on top
                for (Node node : graph.vertexSet()) {
                    Integer communityId = nodeCommunities.get(node);
                    
                    // Skip nodes in community 0 if we're hiding it
                    if (!showCommunityZero && communityId != null && communityId == 0) {
                        continue;
                    }
                    
                    if (communityId != null) {
                        g2d.setColor(communityColors.get(communityId % communityColors.size()));
                    } else {
                        g2d.setColor(Color.BLACK);
                    }

                    int x = 20 + (int)((node.getLocation().getX() - minX) * scale);
                    int y = getHeight() - 20 - (int)((node.getLocation().getY() - minY) * scale);

                    g2d.fillOval(x - 5, y - 5, 10, 10);
                }

                // Draw legend
                int legendX = 20;
                int legendY = 20;
                int legendItemHeight = 12; // Even smaller height
                int legendColumnWidth = 140; // Smaller column width
                Font originalFont = g2d.getFont();
                Font legendFont = originalFont.deriveFont(9.0f); // Smaller font for legend
                g2d.setFont(legendFont);
                
                int maxLegendX = getWidth() - 80; // Use more of the right side
                int maxVisibleCommunities = 200; // Higher limit for number of displayed communities
                
                // Calculate layout for multiple columns
                int visibleCommunities = Math.min(communities.size(), maxVisibleCommunities);
                if (!showCommunityZero) {
                    visibleCommunities = Math.min(communities.size() - 1, maxVisibleCommunities);
                }
                
                int maxItemsPerColumn = (getHeight() - 40) / legendItemHeight;
                int numColumns = (int) Math.ceil((double) visibleCommunities / maxItemsPerColumn);
                int actualItemsPerColumn = (int) Math.ceil((double) visibleCommunities / numColumns);
                
                for (int i = 0; i < communities.size() && i < maxVisibleCommunities; i++) {
                    // Skip community 0 in legend if we're hiding it
                    if (!showCommunityZero && i == 0) {
                        continue;
                    }
                    
                    int displayIndex = showCommunityZero ? i : i - 1;
                    int column = displayIndex / actualItemsPerColumn;
                    int posInColumn = displayIndex % actualItemsPerColumn;
                    
                    int currentLegendX = legendX + (column * legendColumnWidth);
                    int currentLegendY = legendY + (posInColumn * legendItemHeight);
                    
                    // Skip if this would go off screen
                    if (currentLegendX > maxLegendX) {
                        g2d.setColor(Color.BLACK);
                        g2d.drawString("+" + (communities.size() - i) + " more communities...", 
                                       20, getHeight() - 10);
                        break;
                    }
                    
                    g2d.setColor(communityColors.get(i % communityColors.size()));
                    g2d.fillRect(currentLegendX, currentLegendY, 10, 10); // Even smaller squares
                    g2d.setColor(Color.BLACK);
                    g2d.drawRect(currentLegendX, currentLegendY, 10, 10);
                    String label = "Community " + i + " (" + communities.get(i).size() + ")";
                    g2d.drawString(label, currentLegendX + 14, currentLegendY + 9);
                }
                
                // Restore original font
                g2d.setFont(originalFont);
            }
        };

        frame.add(panel);

        // Show the frame and bring it to front
        frame.setVisible(true);
        frame.toFront();

        System.out.println("Communities visualization launched. Found " + communities.size() + " communities.");
        System.out.println("Initializing image saving procedures...");

        // Try multiple times with increasing delays - but without the Robot method
        saveVisualizationAttempt(panel, communities.size(), algorithmName);
    }

    /**
     * Second attempt at saving the visualization - using panel's print method
     * Saves to current working directory
     */
    private void saveVisualizationAttempt(JPanel panel, int communityCount) {
        saveVisualizationAttempt(panel, communityCount, "community");
    }

    /**
     * Second attempt at saving the visualization - using panel's print method
     * Saves to current working directory
     * 
     * @param panel The JPanel containing the visualization
     * @param communityCount The number of communities
     * @param algorithmName The name of the algorithm used
     */
    private void saveVisualizationAttempt(JPanel panel, int communityCount, String algorithmName) {
        try {
            // Create timestamp for filename
            SimpleDateFormat dateFormat = new SimpleDateFormat("yyyyMMdd_HHmmss");
            String timestamp = dateFormat.format(new Date());

            // Create absolute path for current directory
            String currentDir = System.getProperty("user.dir");
            File outputDir = new File(currentDir+"/graphs");
            System.out.println("Using current directory: " + outputDir.getAbsolutePath());

            // Create the buffered image
            BufferedImage image = new BufferedImage(panel.getWidth(), panel.getHeight(), BufferedImage.TYPE_INT_RGB);
            Graphics2D g2d = image.createGraphics();

            // Set high quality rendering
            g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
            g2d.setRenderingHint(RenderingHints.KEY_RENDERING, RenderingHints.VALUE_RENDER_QUALITY);

            // Fill background
            g2d.setColor(Color.WHITE);
            g2d.fillRect(0, 0, panel.getWidth(), panel.getHeight());

            // Have the panel print itself (different from paint)
            panel.print(g2d);
            g2d.dispose();

            // Build filename with construction method included
            String baseFilename = algorithmName + "_" + graphConstructionMethod + "_community_" + communityCount + "_" + timestamp;

            // First try to save as BMP (widely supported format)
            File bmpFile = new File(outputDir, baseFilename + ".bmp");
            // Save as BMP file (simple image format that can be viewed on macOS)
            if (saveAsBMP(image, bmpFile)) {
                System.out.println("Visualization saved as: " + bmpFile.getAbsolutePath());
            } else {
                // Try PPM as fallback
                File ppmFile = new File(outputDir, baseFilename + ".ppm");
                System.out.println("BMP save failed, trying PPM: " + ppmFile.getAbsolutePath());
                
                if (saveAsPPM(image, ppmFile)) {
                    System.out.println("Visualization saved as: " + ppmFile.getAbsolutePath());
                } else {
                    // Last resort - try to save as a plain text report
                    saveAsTextReport(panel, communityCount, algorithmName);
                }
            }

        } catch (Exception e) {
            System.err.println("Save attempt exception: " + e.getMessage());
            e.printStackTrace();
            
            // Last resort - try to save as a plain text report
            saveAsTextReport(panel, communityCount, algorithmName);
        }
    }
    
    /**
     * Saves a BufferedImage directly to a BMP file without using ImageIO.
     * BMP is widely supported by most image viewers including macOS Preview.
     * 
     * @param image The image to save
     * @param outputFile The target file
     * @return True if successful, false otherwise
     */
    private boolean saveAsBMP(BufferedImage image, File outputFile) {

        try (java.io.FileOutputStream fos = new java.io.FileOutputStream(outputFile);
             java.io.BufferedOutputStream bos = new java.io.BufferedOutputStream(fos)) {
            
            int width = image.getWidth();
            int height = image.getHeight();
            
            // Calculate row size (must be multiple of 4 bytes)
            int rowSize = ((3 * width + 3) / 4) * 4;
            int imageSize = rowSize * height;
            int fileSize = 54 + imageSize; // 54 bytes for the header
            
            // BMP file header (14 bytes)
            bos.write('B');                       // Signature 'B'
            bos.write('M');                       // Signature 'M'
            writeInt(bos, fileSize);              // File size in bytes
            writeShort(bos, 0);                   // Reserved1
            writeShort(bos, 0);                   // Reserved2
            writeInt(bos, 54);                    // Offset to pixel data
            
            // DIB header (40 bytes)
            writeInt(bos, 40);                    // Header size
            writeInt(bos, width);                 // Image width
            writeInt(bos, height);                // Image height (negative means top-down)
            writeShort(bos, 1);                   // Planes
            writeShort(bos, 24);                  // Bits per pixel (3 bytes for RGB)
            writeInt(bos, 0);                     // Compression (0 = none)
            writeInt(bos, imageSize);             // Image size
            writeInt(bos, 2835);                  // X pixels per meter (72 DPI)
            writeInt(bos, 2835);                  // Y pixels per meter (72 DPI)
            writeInt(bos, 0);                     // Colors in color table
            writeInt(bos, 0);                     // Important color count
            
            // Write pixel data (bottom-up, row by row)
            byte[] padding = new byte[rowSize - 3 * width];
            for (int y = height - 1; y >= 0; y--) {
                for (int x = 0; x < width; x++) {
                    int rgb = image.getRGB(x, y);
                    // BMP stores as BGR
                    bos.write(rgb & 0xFF);        // Blue
                    bos.write((rgb >> 8) & 0xFF); // Green
                    bos.write((rgb >> 16) & 0xFF);// Red
                }
                // Padding to ensure row size is multiple of 4 bytes
                if (padding.length > 0) {
                    bos.write(padding);
                }
            }
            return true;
            
        } catch (Exception e) {
            System.err.println("Error saving BMP file: " + e.getMessage());
            e.printStackTrace();
            return false;
        }
    }
    
    /**
     * Helper method to write a 4-byte integer to an output stream (little endian)
     */
    private void writeInt(java.io.OutputStream os, int v) throws IOException {
        os.write(v & 0xFF);
        os.write((v >>> 8) & 0xFF);
        os.write((v >>> 16) & 0xFF);
        os.write((v >>> 24) & 0xFF);
    }
    
    /**
     * Helper method to write a 2-byte short to an output stream (little endian)
     */
    private void writeShort(java.io.OutputStream os, int v) throws IOException {
        os.write(v & 0xFF);
        os.write((v >>> 8) & 0xFF);
    }
    
    /**
     * Saves a BufferedImage directly to a PPM file without using ImageIO.
     * PPM is a simple image format that can be written with standard Java I/O.
     * 
     * @param image The image to save
     * @param outputFile The target file
     * @return True if successful, false otherwise
     */
    private boolean saveAsPPM(BufferedImage image, File outputFile) {
        System.out.println("Saving image as PPM file (direct file I/O)...");
        
        try (BufferedWriter writer = new BufferedWriter(new FileWriter(outputFile))) {
            // PPM header (P3 format - ASCII)
            writer.write("P3\n");
            writer.write("# Community visualization\n");
            writer.write(image.getWidth() + " " + image.getHeight() + "\n");
            writer.write("255\n"); // Max color value
            
            // Write pixel data (with sampling to reduce file size)
            int samplingRate = Math.max(1, image.getHeight() > 1000 ? 4 : 2); // Adjust sampling based on image size
            System.out.println("Using sampling rate of " + samplingRate + " for PPM output");
            
            for (int y = 0; y < image.getHeight(); y += samplingRate) {
                for (int x = 0; x < image.getWidth(); x += samplingRate) {
                    int rgb = image.getRGB(x, y);
                    int r = (rgb >> 16) & 0xFF;
                    int g = (rgb >> 8) & 0xFF;
                    int b = rgb & 0xFF;
                    writer.write(r + " " + g + " " + b + " ");
                }
                writer.write("\n");
            }
            
            System.out.println("PPM file written successfully");
            return true;
            
        } catch (Exception e) {
            System.err.println("Error saving PPM file: " + e.getMessage());
            e.printStackTrace();
            return false;
        }
    }
    
    /**
     * Last resort method to save community visualization data as a text report
     * when all image saving methods have failed.
     * 
     * @param panel The panel containing the visualization
     * @param communityCount The number of communities
     */
    private void saveAsTextReport(JPanel panel, int communityCount) {
        saveAsTextReport(panel, communityCount, "community");
    }
    
    /**
     * Last resort method to save community visualization data as a text report
     * when all image saving methods have failed.
     * 
     * @param panel The panel containing the visualization
     * @param communityCount The number of communities
     * @param algorithmName The name of the algorithm used
     */
    private void saveAsTextReport(JPanel panel, int communityCount, String algorithmName) {
        System.out.println("Attempting to save visualization data as text report...");
        
        try {
            SimpleDateFormat dateFormat = new SimpleDateFormat("yyyyMMdd_HHmmss");
            String timestamp = dateFormat.format(new Date());
            String currentDir = System.getProperty("user.dir");
            
            // Include construction method in filename
            File reportFile = new File(currentDir, algorithmName + "_" + graphConstructionMethod + "_community_report_" + communityCount + "_" + 
                                      timestamp + ".txt");
            
            BufferedWriter writer = new BufferedWriter(new FileWriter(reportFile));
            
            writer.write("COMMUNITY VISUALIZATION REPORT\n");
            writer.write("==============================\n");
            writer.write("Algorithm: " + algorithmName + "\n");
            writer.write("Construction Method: " + graphConstructionMethod + "\n");
            writer.write("Generated: " + new Date() + "\n");
            writer.write("Communities: " + communityCount + "\n\n");
            
            writer.write("Community Members:\n");
            
            // Get the graph and node-community mappings from the visualization panel
            // Note: This is just a placeholder - the actual implementation would depend
            // on how you're storing community data in your application
            
            writer.write("\nNote: Image visualization could not be saved due to Java module access restrictions.\n");
            writer.write("Please use the interactive visualization window instead.\n");
            
            writer.close();
            System.out.println("Text report saved to: " + reportFile.getAbsolutePath());
            
        } catch (Exception e) {
            System.err.println("Text report save failed: " + e.getMessage());
            e.printStackTrace();
        }
    }

    /**
     * Generates a list of distinct colors for visualizing communities.
     * 
     * @param count Number of colors needed
     * @return List of distinct colors
     */
    private List<Color> generateCommunityColors(int count) {
        List<Color> colors = new ArrayList<>();
        
        // Add some predefined colors for common use cases
        colors.add(new Color(255, 0, 0));      // Red
        colors.add(new Color(0, 0, 255));      // Blue
        colors.add(new Color(0, 128, 0));      // Green
        colors.add(new Color(255, 165, 0));    // Orange
        colors.add(new Color(128, 0, 128));    // Purple
        colors.add(new Color(0, 128, 128));    // Teal
        colors.add(new Color(255, 192, 203));  // Pink
        colors.add(new Color(128, 128, 0));    // Olive
        colors.add(new Color(165, 42, 42));    // Brown
        colors.add(new Color(0, 255, 255));    // Cyan
        colors.add(new Color(255, 0, 255));    // Magenta
        colors.add(new Color(255, 215, 0));    // Gold
        colors.add(new Color(70, 130, 180));   // Steel Blue
        colors.add(new Color(244, 164, 96));   // Sandy Brown
        colors.add(new Color(46, 139, 87));    // Sea Green
        
        // Generate additional colors if needed - no limit now, generate as many as requested
        Random random = new Random(42); // Fixed seed for reproducibility
        while (colors.size() < count) {
            // Generate more varied colors by spreading them across the color space
            float hue = (float) colors.size() / count;
            float saturation = 0.7f + random.nextFloat() * 0.3f; // 0.7-1.0
            float brightness = 0.7f + random.nextFloat() * 0.3f; // 0.7-1.0
            
            Color color = Color.getHSBColor(hue, saturation, brightness);
            colors.add(color);
        }
        
        return colors;
    }

    /**
     * Saves the community data to a file for further analysis.
     * The format is:
     * node_id,community_id
     *
     * @param communities Map of community IDs to lists of nodes
     */
    public void saveCommunityData(Map<Integer, List<Node>> communities) {
        //saveCommunityData(communities, "community");
    }
    
    /**
     * Saves the community data to a file for further analysis.
     * The format is:
     * node_id,community_id
     *
     * @param communities Map of community IDs to lists of nodes
     * @param algorithmName The name of the algorithm used
     */
    public void saveCommunityData(Map<Integer, List<Node>> communities, String algorithmName) {
        try {
            SimpleDateFormat dateFormat = new SimpleDateFormat("yyyyMMdd_HHmmss");
            String timestamp = dateFormat.format(new Date());
            String currentDir = System.getProperty("user.dir");
            
            // Include construction method in filename
            File csvFile = new File(currentDir, algorithmName + "_" + graphConstructionMethod + "_community_data_" + 
                                  timestamp + ".csv");
            BufferedWriter writer = new BufferedWriter(new FileWriter(csvFile));
            
            // Write header
            writer.write("node_id,community_id,latitude,longitude\n");
            
            // Write data
            for (Map.Entry<Integer, List<Node>> entry : communities.entrySet()) {
                int communityId = entry.getKey();
                for (Node node : entry.getValue()) {
                    // Only include nodes with location data
                    if (node.getLocation() != null) {
                        double lat = node.getLocation().getY(); // Y coordinate is latitude
                        double lon = node.getLocation().getX(); // X coordinate is longitude
                        writer.write(node.getId() + "," + communityId + "," + lat + "," + lon + "\n");
                    }
                }
            }
            
            writer.close();
            System.out.println("Community data saved to " + csvFile.getAbsolutePath());
        } catch (IOException e) {
            System.err.println("Error writing community data: " + e.getMessage());
        }
    }

    /**
     * Assigns communities to nodes that weren't assigned by the clustering algorithm.
     * This ensures all nodes have a community and prevents black nodes in visualization.
     * 
     * @param nodeCommunities The map of nodes to their community IDs
     */
    private void assignMissingCommunities(Map<Node, Integer> nodeCommunities) {
        List<Node> unassignedNodes = new ArrayList<>();
        
        // Find all nodes without a community
        for (Node node : graph.vertexSet()) {
            if (!nodeCommunities.containsKey(node)) {
                unassignedNodes.add(node);
            }
        }
        
        // Skip if there are no unassigned nodes
        if (unassignedNodes.isEmpty()) {
            return;
        }
        
        System.out.println("Found " + unassignedNodes.size() + " unassigned nodes, assigning to nearest communities...");
        
        // For each unassigned node, find the closest assigned node and use its community
        for (Node unassignedNode : unassignedNodes) {
            Node closestNode = null;
            double minDistance = Double.MAX_VALUE;
            
            // Find the closest assigned node
            for (Map.Entry<Node, Integer> entry : nodeCommunities.entrySet()) {
                Node assignedNode = entry.getKey();
                double distance = unassignedNode.getLocation().distance(assignedNode.getLocation());
                
                if (distance < minDistance) {
                    minDistance = distance;
                    closestNode = assignedNode;
                }
            }
            
            // Assign the unassigned node to the same community as the closest node
            if (closestNode != null) {
                nodeCommunities.put(unassignedNode, nodeCommunities.get(closestNode));
            } else {
                // If somehow we can't find a closest node, assign to community 0
                nodeCommunities.put(unassignedNode, 0);
            }
        }
    }

    /**
     * Sets the graph construction method used for this transportation network.
     * This will be included in saved file names for better traceability.
     * 
     * @param methodName The name of the construction method used
     */
    public void setGraphConstructionMethod(String methodName) {
        this.graphConstructionMethod = methodName;
    }
    
    /**
     * Gets the current graph construction method name.
     * 
     * @return The name of the construction method
     */
    public String getGraphConstructionMethod() {
        return this.graphConstructionMethod;
    }
} 